#include "Utils.s3d"

class Serializer
{
	var class_instance;
	var attributes;
	Serialize(c);
	Deserialize(sstring);
};

function Serializer::Serializer()
{
	attributes = array(0);
}

function Serializer::Serialize(c)
{
	var instance, attributes;
	var sstring = "";
	if(valtype(c) == "O")
	{
		var factor = callback(c.__GetName()+"_Factory");
		instance = factor[0];
		attributes = factor[1];
	
		foreach(var a in attributes)
		{
			instance.__SET(a,c.__GET(a));
		}
		sstring = "{$" + instance.__GetName() + " ";
		for(var i = 0; i < len(attributes); i++)
		{
			var value = instance.__Get(attributes[i]);
			switch(valtype(value)[0])
			{
				case "O":
					sstring += attributes[i] + ":" + Serialize(value);
					if(i != len(attributes) - 1)
					{
						sstring += ",";
					}
					break;
				case "A":
					sstring += attributes[i] + ":" + "[";
					for(var v = 0; v<len(value); v++)
					{
						sstring += Serialize(value[v]);
						if(v!=len(value)-1)
							sstring += " ";
					}
					sstring += "]";
					if(i != len(attributes) -1)
						sstring += ",";
					break;
				case "V":
					sstring += attributes[i] + ":" + "[";
					for(var v = 0; v<len(value); v++)
					{
						sstring += Serialize(value[v]);
					}
					sstring += "],";
					break;
				default:
					sstring += attributes[i] + ":" + VarStringEncode(instance.__Get(attributes[i]));
					if(i != len(attributes) - 1)
					{
						sstring += ",";
					}
					break;
			}
		} 
		sstring += "},";
	} else {
		sstring += VarStringEncode(c) + ",";
	}
	return sstring;
}

function mapString(_s, start, end)
{
	var map = array(0);
	var m = "";
	var depth = 0;
	start = (start != Void) ? start : 0;
	end = (end != Void) ? end : len(_s);
	for(var i = start; i<end; i++)
	{	
		var s = _s[i];
		if(s == "{" || s == "[")
		{
			depth ++;	
			m += s;
		}
		else if(s == "}" || s == "]")
		{
			depth --;
			m += s;
		}
		else if((s == "," && depth == 0 && m != "") || (m == "" && s[i] == " "))
		{
			aadd(map, m);
			m = "";
		}
		else if((s == "," && depth == 0 && m == ""))
			i;
		else
			m += s;
		if(i == end-1)
			aadd(map,m);
	}
	return map;
}

function Serializer::Deserialize(s)
{
	var keys = array(0);
	var values = array(0);
	
	if(s[0] == "{"){
		var i = indexOf(s, " ", 2);
		var c = substr(s, 2, i);
//		trace(c);
		var _instance = callback(substr(c, 0, len(c))+"_Factory");
		_instance = _instance[0];
		var instance_string = substr(s, ++i, reverseIndexOf(s, "}"));
//		trace(instance_string);
		var map = mapString(instance_string);
//		trace(map);
		for(var i = 0; i <len(map); i++)
		{
			var kv = ssplit(map[i], ":", 0, indexOf(map[i], "$")+1);
//			trace(kv);
			var k = kv[0];
			var v = kv[1];
			
			_instance.__SET(k, Deserialize(v));
		}
		return _instance;
	}
	else if(s[0] == "[")
	{
		var depth = 0;
		var map = array(0);
		var m = "";
		for(var i = 1; i<len(s)-1; i++)
		{	
			if(s[i] == "{" || s[i] == "[")
			{
				depth ++;	
				m += s[i];
			}
			else if(s[i] == "}" || s[i] == "]")
			{
				depth --;
				m += s[i];
			}
			else if((s[i] == "," && depth == 0 && m != ""))
			{
				aadd(map, m);
				m = "";
			}
			else if((s[i] == "," && depth == 0 && m == "") || (m == "" && s[i] == " "))
				i;
			else
				m += s[i];
			if(i == len(s)-1)
			{	
				aadd(map,m);
			}
		}
		var _instance = array(0);
		for(var i = 0; i<len(map); i++)
		{
			aadd(_instance, Deserialize(map[i]));
		}
//		trace(_instance);
		return _instance;
	}
	else
	{
//		outputln(s);
		return VarStringDecode(s);
	}
}
